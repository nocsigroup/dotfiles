# ~/.config/direnv/direnvrc: Global configuration for direnv to make it compliant
# with pyenv -- see https://direnv.net/
#
# Adapted from
#  - https://github.com/direnv/direnv/wiki/Python#-pyenv and
#  - https://github.com/direnv/direnv/wiki/Python#-virtualenvwrapper
# use a certain pyenv version
source ~/.bin/helpers.sh

nvm() {
  . ~/.nvm/nvm.sh
  nvm "$@"
}

use_nvm() {
  local node_version=$1

  if [[ $node_version = "package.json" ]]; then
    if has jq; then
      node_version=$(jq --raw-output .engines.node package.json | tr -d "<=> ")
    else
      echo "Parsing package.json for node version to use with direnv requires jq"
    fi
  fi

  nvm_sh=$HOME/.nvm/nvm.sh
  if [[ -e $nvm_sh ]]; then
    source $nvm_sh
    nvm use $node_version
  fi
}


use_python() {
    if [ -n "$(which pyenv)" ]; then
        local pyversion=$1
        pyenv local ${pyversion}
    fi
}
layout_virtualenv() {
    local pyversion=$1
    local pvenv=$2
    if [ -n "$(which pyenv-virtualenv)" ]; then
        pyenv virtualenv --force --quiet ${pyversion} ${pvenv}-${pyversion}
    fi
    pyenv local --unset
}
layout_activate() {
    if [ -n "$(which pyenv)" ]; then
        source $PYENV_ROOT/versions/$1/bin/activate
    fi
}

layout_haskell() {
  PATH_add ~/.cabal/bin
  [ -d .cabal-sandbox ] || cabal sandbox init
  PATH_add .cabal-sandbox/bin
  export GHC_PACKAGE_PATH=$(cabal exec -- sh -c "echo \$GHC_PACKAGE_PATH")
}

set_credentials() {
  namespace="$1"
  for env in ${@:2}; do
    if ! envchain $namespace printenv $env >/dev/null 2>&1; then
      envchain -- set $namespace $env
    else 
      echo "Already set \$$env"
    fi
  done
}

add_extra_vimrc() {
  local extravim="$(find_up .vimrc)"
  if [ -n "$extravim" ]; then
    echo "Adding extra .vimrc: ${extravim}"
    path_add EXTRA_VIM $extravim
  fi
}

# Usage: use_nix [...]
#
# Load environment variables from `nix-shell`.
# If you have a `default.nix` or `shell.nix` one of these will be used and
# the derived environment will be stored at ./.direnv/env-<hash>
# and symlink to it will be created at ./.direnv/default.
# Dependencies are added to the GC roots, such that the environment remains persistent.
#
# Packages can also be specified directly via e.g `use nix -p ocaml`,
# however those will not be added to the GC roots.
#
# The resulting environment is cached for better performance.
#
# To trigger switch to a different environment:
# `rm -f .direnv/default`
#
# To derive a new environment:
# `rm -rf .direnv/env-$(md5sum {shell,default}.nix 2> /dev/null | cut -c -32)`
#
# To remove cache:
# `rm -f .direnv/dump-*`
#
# To remove all environments:
# `rm -rf .direnv/env-*`
#
# To remove only old environments: 
# `find .direnv -name 'env-*' -and -not -name `readlink .direnv/default` -exec rm -rf {} +`
#
use_nix() {
    set -e

    local shell="shell.nix"
    if [[ ! -f "${shell}" ]]; then
        shell="default.nix"
    fi

    if [[ ! -f "${shell}" ]]; then
        fail "use nix: shell.nix or default.nix not found in the folder"
    fi

    local dir="${PWD}"/.direnv
    local default="${dir}/default"
    if [[ ! -L "${default}" ]] || [[ ! -d `readlink "${default}"` ]]; then
        local wd="${dir}/env-`md5sum "${shell}" | cut -c -32`" # TODO: Hash also the nixpkgs version?
        mkdir -p "${wd}"

        local drv="${wd}/env.drv"
        if [[ ! -f "${drv}" ]]; then
            log_status "use nix: deriving new environment"
            IN_NIX_SHELL=1 nix-instantiate --add-root "${drv}" --indirect "${shell}" > /dev/null
            nix-store -r `nix-store --query --references "${drv}"` --add-root "${wd}/dep" --indirect > /dev/null
        fi

        rm -f "${default}"
        ln -s `basename "${wd}"` "${default}"
    fi

    local drv=`readlink -f "${default}/env.drv"`
    local dump="${dir}/dump-`md5sum ".envrc" | cut -c -32`-`md5sum ${drv} | cut -c -32`"

    if [[ ! -f "${dump}" ]] || [[ "${XDG_CONFIG_DIR}/direnv/direnvrc" -nt "${dump}" ]]; then
        log_status "use nix: updating cache"

        old=`find ${dir} -name 'dump-*'`
        nix-shell "${drv}" --show-trace "$@" --run 'direnv dump' > "${dump}"
        rm -f ${old}
    fi

    direnv_load cat "${dump}"

    watch_file "${default}"
    watch_file shell.nix
    if [[ ${shell} == "default.nix" ]]; then
        watch_file default.nix
    fi
}

use_erlang() {
    OTP_VERSION="$1"
    if has kerl; then
        OTP_INSTALLATION=$(kerl list installations | grep "^$OTP_VERSION " | cut -d' ' -f2)
        if [ -s "$OTP_INSTALLATION/activate" ] ; then
            tput setaf 2
            echo "Using Erlang/OTP $OTP_VERSION (in $OTP_INSTALLATION) via kerl"
            tput sgr0
            . "$OTP_INSTALLATION/activate"

            export OTP_ROOT="$OTP_INSTALLATION"
            export OTP_VERSION
        else
            tput setaf 1
            echo "Erlang/OTP $OTP_VERSION not available via kerl; using default"
            tput sgr0
        fi
    else
        tput setaf 1
        echo "kerl not available; using default Erlang"
        tput sgr0
    fi
}

use_elixir() {
    ELIXIR_VERSION="$1"
    if has kiex; then
        if [ -s "$HOME/.kiex/elixirs/elixir-$ELIXIR_VERSION.env" ]; then
            tput setaf 2
            echo "Using Elixir $ELIXIR_VERSION via kiex"
            tput sgr0
            . "$HOME/.kiex/elixirs/elixir-$ELIXIR_VERSION.env"
        else
            tput setaf 1
            echo "Elixir $ELIXIR_VERSION not available via kiex; using default"
            tput sgr0
        fi
    else
        tput setaf 1
        echo "kiex not available; using default Elixir"
        tput sgr0
    fi
}

use_ruby() {
  local ruby_root=$HOME/.rubies/$1
  load_prefix "$ruby_root"
  layout_ruby
}

use_docker-machine(){
  local env=${1:-default}
  echo Docker machine: $env
  local machine_cmd=$(docker-machine env --shell bash $env)

  eval $(docker-machine env --shell bash $env)
}
